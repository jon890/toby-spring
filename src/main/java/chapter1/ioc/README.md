## 4. 제어의 역전 (ioc package => IoC : Inversion of Control)

### 1. 오브젝트 팩토리

- UserDaoTest에는 현재 두 개의 관심사가 있다

1. UserDao 테스트
2. 어떤 방식으로 ConnectionMaker를 구현한 클래스를 가져올 것인가

- 어떤 ConnectionMaker 구현 클래스를 사용할지를 결정하는 것을 엉겁결에 떠 맡았다
- 분리하자!
- 어떻게 분리할 것인가

1. UserDao와 ConnectionMaker 구현 클래스 객체를 만들기
2. 그렇게 만들어진 두 개의 객체가 연결돼서 사용될 수 있도록 관계 맺어주기

#### 팩토리

- 팩토리 : 객체의 생성 방법을 결정하고 그렇게 만들어진 객체를 돌려주는것
- 디자인 패턴에서의 추상 팩토리 패턴이나 팩토리 메소드 패턴과는 다르다! 혼동 주의!!
- 단지 객체를 생성하는 쪽과 생성된 객체를 사용하는 쪽의 역할과 책임을 분리하는 목적으로 사용
- 어떻게 만들지와 어떻게 사용할지는 분명히 다른 관심이다

#### 설계도로서의 팩토리

- 이렇게 분리된 객체들의 역할과 관계를 분석해보자
- UserDao와 ConnectionMAker는 각각 애플리케이션의 핵심적인 데이터 로직과 기술로직을 담당한다 (컴포넌트)
- DaoFactory는 이런 애플리케이션의 객체를 구성하고 그 관계를 정의하는 책임을 맡는다 (설계도)

### 2. 제어권의 이전을 통한 제어관계의 역전

- 제어의 역전 : 간단히 프로그램의 제어 흐름 구조가 뒤바뀌는 것
- 일반적인 프로그램의 흐름 : main() 메소드 같이 프로그램이 시작되는 지점에서 다음에 사용할 객체를 결정하고, 결정한 객체를 생성하고, 만들어진 객체에 있는 메소드를 호출하고, 그 객체 메소드 안에서 다음에
  사용할 것을 결정하고 호출하는 식의 작업이 반복된다
- 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조다


- 제어의 역전이란 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다
- 제어의 역전에서는 객체가 자신이 사용할 객체를 스스로 선택하지 않는다
- 모든 제어 권한을 자신이 아닌 다른 대상에게 <b>위임하기</b> 때문이다


- 우리가 만들었던 템플릿 메소드 패턴을 생각해보자.
- 추상 UserDao를 상속한 서브클래스는 getConnection()을 구현한다.
- 하지만 이 메소드가 언제 어떻게 사용될지 자신은 모른다
- 즉 제어권을 상위 템플릿 메소드에 넘기고 자신은 필요할 때 호출되어 사용되도록 한다는, 제어의 역전 개념을 발견할 수 있다.


- 프레임워크도 제어의 역전 개념이 적용된 대표적인 기술이다.
- 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다.
- 단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다.
- <b>반면에</b> 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다.
- 보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다.


- 제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계서ㅏㄹ정, 사용, 생명주기 관리 등을 관장하는 존재가 필요하다.
- DaoFactory는 가장 단순한 IoC 컨테이너 또는 IoC 프레임워크로 불릴 수 있다
- IoC를 애플리케이션 ㅈ넌반에 걸쳐 본격적으로 적용하려면 스프링과 같은 IoC 프레임워크의 도움을 받는 편이 유리하다
