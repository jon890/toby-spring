## 5. 템플릿과 콜백

- 전략 패턴 : 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고 그중 일부분만 자주 바꿔서 사용해야 하는 경우에 적합한 구조
- 전략 패턴의 기본구조 + 익명 내부 클래스 (람다) 활용
- 스프링에서는 이런 방식을 템플릿/콜백 패턴이라고 부른다
- 템플릿 : 전략 패턴의 컨텍스트
- 콜백 : 익명 내부 클래스 (람다) (Function Object)

### 1. 템플릿/콜백의 동작원리

- 템플릿/콜백 패턴의 콜백은 보통 단일 메소드 인터페이스를 사용한다
- 템플릿의 작업 흐름 중 특정 기능을 위해 한 번 호출되는 경우가 일반적이기 때문이다
- 콜백은 일반적으로 하나의 메소드를 가진 인터페이스를 구현한 익명 내부 클래스로 만들어진다고 보면 된다


- 콜백 인터페이스의 메소드에는 보통 파라미터가 있다
- 이 파라미터는 템플릿의 작업 흐름 중에 만들어지는 컨텍스트 정보를 전달받을 때 사용된다
- JdbcContext에서는 템플릿인 workWithStatementStrategy() 메소드 내에서 생성한 Connection 오브젝트를 콜백의 메소드인 makePreparedStatement()를 실행할 떄
  파라미터로 넘겨준다


- 클라이언트의 역할
    1. 템플릿 안에서 실행될 로직을 담은 콜백 오브젝트를 만들고, 콜백이 참조할 정보 제공
    2. 만들어진 콜백은 클라이언트가 템플릿의 메소드를 호출할 때 파라미터로 전달

- 템플릿의 역할
    1. 정해진 작업 흐름을 따라 진행하다가 내부에서 생성한 참조정보를 가지고 콜백 오브젝트의 메소드를 호출
    2. 템플릿은 콜백이 돌려준 정보를 사용해서 작업을 마저 수행
    3. 경우에 따라 최종 결과를 클라이언트에 다시 돌려주기도 함

- 콜백의 역할
    1. 클라이언트 메소드에 있는 정보와 템플릿이 제공한 참조정보를 이용해서 작업을 수행하고 그 결과를 다시 템플릿에 돌려줌


- 일반적인 DI와 다른점
    1. 템플릿이 사용할 콜백 인터페이스를 구현한 오브젝트를 메소드를 통해 주입해주는 DI 작업이 클라이언트가 템플릿의 기능을 호출하는 것과동시에 일어난다
    2. 템플릿/콜백 방식에서는 매번 메소드 단위로 사용할 오브젝트를 새롭게 전달 받음
    3. 콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조
    4. 클라이언트와 콜백이 강하게 결합


- 템플릿/콜백 방식 => 전략 패턴과 DI의 장점을 익명 내부 클래스 사용 전략과 결합한 독특한 활용법

### 2. 편리한 콜백의 재활용

- 클라이언트인 DAO의 메소드는 간결해지고 최소한의 데이터 엑세스 로직만 갖고 있게 되었다
- 그런데 템플릿/콜백 방식에서 한 가지 아쉬운 점이 있다
- DAO 메소드에서 매번 익명 내부 클래스를 사용하기 때문에 코드를 작성하고 읽기가 조금 불편하다

#### 콜백의 분리와 재활용

~~~
  JdbcContext 내에 executeSql() 메소드를 만들어서 재활용 한다
  
    public void executeSql(final String query) throws SQLException {
        workWithStatementStrategy(connection -> connection.prepareStatement(query));
    }
~~~

### 3. 템플릿/콜백의 응용

- 지금까지 살펴본 템플릿/콜백 패턴은 스프링이 제공해주는 독점적인 기술은 아니다
- 하지만 스프링만큼 이 패턴을 적극적으로 활용하는 프레임워크는 없다
- 스프링에는 다양한 자바 엔터프라이즈 기술에서 사용할 수 있도록 미리 만들어져 제공되는 수십 가지 템플릿/콜백 클래스와 API가 있다


- 스프링을 사용하는 개발자라면 당연히 스프링이 제공하는 템플릿/콜백 기능을 잘 사용할 수 있어야 한다
- 동시에 템플릿/콜백이 필요한곳이 있으면 직접 만들어서 사용할 줄도 알아야 한다
- 스프링이 제공하는 대부분의 기술은 그 구조를 이해하면 손쉽게 확장해서 쓸 수 있다
- 기본적으로 OCP를 지키고, 전략 패턴과 DI를 바탕에 깔고 있으니 원한다면 언제든지 확장해서 편리한 방법으로 사용할 수 있다
- 그런 면에서 스프링의 기본이 되는 전략 패턴과 DI는 물론이고 템플릿/콜백 패턴도 익숙해지도록 학습할 필요가 있다


- 고정된 작업 흐름을 갖고 있으면서 여기저기서 자주 반복되는 코드가 있다면, 중복되는 코드를 분리할 방법을 생각해보는 습관을 기르자
- 중복된 코드는 먼저 메소드로 분리하는 간단한 시도를 해본다
- 그중 일부 작업을 필요에 따라 바꾸어 사용해야 한다면 인터페이스를 사이에 두고 분리해서 전략 패턴을 적용하고 DI로 의존관계를 관리하도록 만든다
- 그런데 바뀌는 부분이 한 애플리케이션 안에서 동시에 여러 종류가 만들어질 수 있다면 이번엔 템플릿/콜백 패턴을 적용하는 것을 고려해볼 수 있다


- try/catch/finally에 적용해보자 => 파일을 읽어서 처리하는 BufferedReader로 연습해보기
- 간단하게 파일을 한 줄씩 읽어서 계산기를 만들어보자
- 중복되는 로직을 템플릿으로 분리하고, 한 줄씩 읽어서 처리하는 LineCallback 인터페이스를 만든다

~~~
    템플릿 메소드
    
    public <T> T lineReadTemplate(String filePath, LineCallback<T> callback, T initValue) throws IOException {
        BufferedReader bufferedReader = null;

        try {
            bufferedReader = new BufferedReader(new FileReader(filePath));
            T res = initValue;
            String line = null;
            while ((line = bufferedReader.readLine()) != null) {
                // 콜백 오브젝트 호출
                // 템플릿에서 만든 컨텍스트 정보인
                // line 과 value 를 전달하고 값을 저장한다
                res = callback.doSomethingWithLine(line, res);
            }

            return res;
        } catch (IOException e) {
            System.out.println(e.getMessage());
            throw e;
        } finally {
            if (bufferedReader != null) {
                try {
                    bufferedReader.close();
                } catch (IOException e) {
                    System.out.println(e.getMessage());
                }
            }
        }
    }
~~~

~~~
  콜백 인터페이스에 제너릭 활용
  
  public interface LineCallback<T> {
      T doSomethingWithLine(String line, T value);
  }
~~~

- 이렇게 범용적으로 만들어진 템플릿/콜백을 이용하면 파일을 라인 단위로 처리하는 다양한 기능을 편리하게 만들 수 있다
- 새롭게 살펴본 리턴 값을 갖는 템플릿이나 탬플릿 내에서 여러 번 호출되는 콜백 오브젝트
- 또 제네릭 타입을 갖는 메소드나 콜백 인터페이스 등의 기법은
- 스프링의 템플릿/콜백 패턴이 적용된 곳에서 종종 사용되고 있다