## 3. JDBC 전략 패턴의 최적화

- 지금까지 기존의 deleteAll() 메소드에 담겨 있던 변하지 않는 부분, 자주 변하는 부분을 전략 패턴을 사용해 깔끔하게 분리해냈다
- 독립된 JDBC 작업 흐름이 담긴 메소드는 DAO 메소드들이 공유할 수 있게 됐다
- DAO 메소드는 전략 패턴의 클라이언트로서 컨텍스트 메소드에 적절한 전략, 즉 바뀌는 로직을 제공해주는 방법으로 사용할 수 있다
- 컨텍스트 : PreparedStatement를 실행하는 JDBC의 작업 흐름
- 전략 : PreparedStatement 생성

### 1. 전략 클래스의 추가 정보

- 생성자 주입을 통하여 추가 정보를 넣어준다
- 참고 : AddStatement

### 2. 전략과 클라이언트의 동거

- 여기서 만족하지 말고 좀 더 개선할 부분을 찾아보자
- 개선할점 1 : DAO 메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 함 =>  
  클래스 파일의 갯수가 늘어남 => 상속을 사용하는 템플릿 메소드 패턴을 적용했을 때보다 그다지 나을게 없다
- 개선할점 2 : User와 같은 부가적인 정보가 있는 경우, 이를 위해 오브젝트를 전달받는 생성자와 이를 저장해둘 인스턴스 변수를 번거롭게 만들어야 함

#### 로컬 클래스 (메소드 레벨에 정의)

- 메소드마다 추가해야 했던 클래스 파일을 줄일 수 있다
- 내부 클래스의 특징을 이용해 로컬 변수를 바로 가져다 사용할 수 있다

#### 익명 내부 클래스 (메소드 레벨에 이름을 갖지 않는 클래스)

- 잡에는 이름조차 필요 없는 익명 내부 클래스가 있다
- 클래스 선언과 오브젝트 생성이 결합된 형태로 만들어진다
- 클래스를 재사용할 필요가 없고, 구현한 인터페이스 타입으로만 사용할 경우에 유용하다