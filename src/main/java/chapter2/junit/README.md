## 3. 개발자를 위한 테스팅 프레임워크 Junit (junit package)

- JUnit은 사실상 자바의 표준 테스팅 프레임워크라고 불릴 만큼 폭넓게 사용되고 있음
- 따라서 스프링을 학습하고 제대로 활용하려면 최소한의 JUnit 테스트 작성 방법과 실행 방법은 알고 있어야 한다
- 다시 말하지만 테스트 없이는 스프링도 의미 없다
- 스프링 프레임워크 자체도 Junit 프레임워크를 이용해 테스트를 만들어가며 개발됬다
- 우리는 <b>IntelliJ IDE</b>의 도움을 받아서 JUnit 테스트를 실행하자!
- 빌드 툴에서 테스트 실행 : Gradle -> Tasks -> Verification - test

### 2. 테스트 결과의 일관성

- 불편했던 것 : 이전 테스트를 실행했을 떄 등록됐던 사용자 정보와 기본키가 중복된다면서 에러가 발생
- 여기서 생각해볼 문제는 테스트가 외부 상태에 따라 성공하기도 하고 실패하기도 한다는 점
- 별도의 준비 작업 없이는 성공해야 마당한 테스트가 실패하기도 한다는 점이 문제
- 반복적으로 테스트를 했을 떄 테스트가 실패하기도 하고 성공하기도 한다면 이는 좋은 테스트가 아님
- 코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야함
- 가장 좋은 해결책은 addAndGet() 테스트를 마치고 나면 테스트가 등록한 사용자 정보를 삭제해서, 테스트를 수행하기 이전 상태로 만들어 주는 것이다


- UserDao에 deleteAll(), getCount() 메소드 추가
- deleteAll(), getCount() 메소드는 어떻게 테스트 할까?
- 기존의 addAndGet() 테스트를 확장하는 방법을 사용하자
- User를 add() 하기전에 deleteAll() 을 수행하고, getCount() 가 0인지 검증한다
- User를 add() 후에 getCount()가 1인지 검증한다
- 이제 동일한 결과를 보장하는 테스트가 되었다!
- 단위 테스트는 항상 일관성 있는 결과과 보장돼야 한다는 점을 잊지 말자

### 3. 포괄적인 테스트

- getCount()에 대한 좀 더 꼼꼼한 테스트를 만들어보자.
- 이번에는 여러 개의 User를 등록해가면서 getCount()의 결과를 매번 확인해보겠다

#### addAndGet() 테스트 보완

- id를 조건으로 해서 사용자를 검색하는 기능을 가진 get()에 대한 테스트는 조금 부족한 감이 있다
- get()이 파라미터로 주어진 id에 해당하는 사용자를 가져온 것인지, 그냥 아무거나 가져온 것인지 테스트에서 검증하지는 못했다.
- 2명의 User를 등록하고, 각 User의 id를 파라미터로 전달해서 get()을 실행하도록 만들어보자
- 이렇게 하면 주어진 id에 해당하는 정확한 User 정보를 가져오는지 확인할 수 있다

#### get() 예외조건에 대한 테스트

- get() 메소드에 전달된 id 값에 해당하는 사용자 정보가 없다면 어떻게 될까?
- 이럴 떈 어떤 결과가 나오면 좋을까?
- 하나는 null과 같은 특별한 값을 리턴하는 것이고, 다른 하나는 id에 해당하는 정보를 찾을 수 없다고 예외를 던지는 것이다
- 스프링이 정의한 데이터 엑세스 예외 클래스를 사용해보자 => EmptyResultDataAccessException
- UserDao의 get() 메소드를 수정하여 User가 null이면 EmptyResultDataAccessExpcetion을 던지게 하자
- 그리고 assertThrows() 메소드를 통하여 오류가 던져졌는지 검증한다

#### 포괄적인 테스트

- 사실 JDBC를 이용한 DAO를 개발해본 경험이 많은 개발자라면, 이 정도의 간단한 DAO는 굳이 이런 다양한 테스트를 하지 않고 코드만 살펴봐도 문제가 생기지 않으리라고 자신할 수 있을지도 모르겠다
- 하지만 이렇게 DAO의 메소드에 대한 포괄적인 테스트를 만들어두는 편이 훨씬 안전하고 유용하다


- 개발자가 테스트를 직접 만들 때 자주하는 실수가 하나있다
- 바로 성공하는 테스트만 골라서 만드는 것이다
- 하지만 개발자도 조금만 신경을 쓰면 자신이 만든 코드에서 발생할 수 있는 다양한 상황과 입력 값을 고려하는 포괄적인 테스트를 만들 수 있다
- 스프링의 창시자인 로드 존슨은 "항상 네거티느 테스트를 먼저 만들라"는 조언을 했다
- 그래서 테스트를 작성할 떄 부정적인 케이스를 먼저 만드는 습관을 들이는게 좋다
- get() 메소드의 경우라면, 존재하는 id가 주어졌을 때 해당 레코드를 정확히 가져오는가를 테스트하는 것도 중요하지만
- 존재하지 않는 id가 주어졌을 때는 어떻게 반응할지 먼저 결정하고
- 이를 확인할 수 있는 테스트를 먼저 만들려고 한다면 예외적인 상황을 빠뜨리지 않는 꼼꼼한 개발이 가능하다

### 4. 테스트가 이끄는 개발

- get() 메소드의 예외 테스트를 만드는 과정을 다시 돌아보면 한 가지 흥미로운 점이 있다
- 작업한 순서를 생각하면 테스트를 먼저 만들어 테스트가 실패하는 것을 보고 나서 UserDao의 코드에 손을 대기 시작했다
- 이런 순서를 따라서 개발을 진행하는 구체적인 개발 전략이 존재한다


- 추가하고 싶은 기능을 일반 언어가 아니라 테스트 코드로 표현해서
- 마치 코드로 된 설계문서처럼 만들어놓은 것이라고 생각해보자
- 그러고 나서 실제 기능을 가진 애플리케이션 코드를 만들고 나면, 바로 이 테스트를 실행해서 설계한 대로 코드가 동작하는지를 빠르게 검증할 수 있다
- 결국 테스트가 성공한다면, 그 순간 코드 구현과 테스트라는 두 가지 작업이 동시에 끝난다!


- 테스트 주도 개발 (TDD) : 만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법
- 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다는 것이 TDD의 기본 원칙이다
- 이 원칙을 따랐다면 모든 코드는 빠짐없이 테스트로 검증된 것이라고 볼 수 있다


- 머릿속에서 진행되는 테스트는 제약이 심하고, 오류가 많고, 나중에 다시 반복하기 힘들다
- 그래서 차라리 머릿속에서 복잡하게 진행하던 작업을 실제 코드로 끄집어 내놓으면 이게 바로 TDD가 된다


- 혹시 테스트를 만들고 자주 실행하면 개발이 지연되지 않을까 염려할지도 모르겠다
- 테스트는 애플리케이션 코드보다 작성하기 쉬운데다 각 테스트가 독립적이기 떄문에, 코드의 양에 비해 작성하는 시간은 얼마 걸리지 않는다
- 게다가 테스트 덕분에 오류를 빨리 잡아낼 수 있어서 전체적인 개발 속도는 오히려 빨라진다

### 5. 테스트 코드 개선

- 애플리케이션 코드만이 리팩토링의 대상이 아니다
- 필요하다면 테스트 코드도 언제든지 내부구조와 설계를 개선해서 좀 더 깔끔하고 이해하기 쉬우며 변경이 용이한 코드로 만들 필요가 있다
- 테스트 코드 자체가 이미 자신에 대한 테스트이기 떄문에 테스트결과가 일정하게 유지된다면 얼마든지 리팩토링을 해도 좋다

    JUnit4가 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식
    1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다
    2. 테스트 클래스의 오브젝트를 하나 만든다
    3. @Before가 붙은 메소드가 있으면 실행한다
    4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다
    5. @After가 붙은 메소드가 있으면 실행한다
    6. 나머지 테스트 메소드에 대해 2~5번을 반복한다
    7. 모든 테스트의 결과를 종합해서 돌려준다

- 주의 JUnit5 (Jupiter)는 조금 다른듯하다
- @BeforeAll, @BeforeEach가 따로 있다
- 각 테스트마다 테스트 클래스 객체를 따로 만들지는 않는듯
- @BeforeAll로 선언하면 static으로 작성해야 한다 
- 픽스쳐 : 테스트를 수행하는 데 필요한 정보나 오브젝트 => dao, user => 중복을 @BeforeAll 에서 수행!


