## 3. DAO의 확장 (expansion package)

- 객체는 변한다
- DB 연결 방법, 데이터 엑세스 로직의 관심을 상하위 클래스로 분리시켜왔다 => 두 개의 관심은 변화의 성격이 다르다
- 변화의 성격 => 변화의 이유와 시기, 주기가 다르다
- DB 연결 방법의 변화 => MyUserDao (현재는 PostgreSqlDao 만 변화하면 됨!) => 데이터 엑세스 로직에 관심이 있는 UserDao는 변화 X
- 추상 클래스를 만들고 이를 상속한 서브클래스에서 변화가 필요한 부분을 바꿔서 쓸수 있게 만든 이유 => 변화의 성격이 다른 것을 분리 => 각각 필요한 시점에 독립적으로 변경 가능
- 하지만!! 상속이라는 방법은 매우 강력하게 결합된다!!

### 3.1 클래스 분리
- 두 개의 관심사를 본격적으로 독립시키면서 동시에 손쉽게 확장할 수 있는 방법
- 이제까지는 독립된 메소드로 만들어서 분리 => 상하위 클래스로 분리
- 이번에는? => 완전히 독립적인 클래스로 만들어보자!
- SimpleConnectionMaker 클래스 생성
- 하지만! UserDao가 바뀔 수 있는 정보, 즉 DB 커넥션을 가져오는 클래스에 대해 너무 많이 알고있음
- 어떤 클래스가 쓰이는지, 그 클래스에서 커넥션을 가져오는 메소드의 이름은 뭔지 알고 있어야한다
- 따라서 UserDao가 SimpleConnectionMaker라는 특정 클래스와 그 코드에 종속적이게 된다

### 3.2 인터페이스의 도입
- 두 개의 클래스가 서로 긴밀하게 연결되지 않도록 중간에 추상적인 느슨한 연결고리를 만들자!
- 추상화 => 공통적인 성격을 뽑아내어 이를 따로 분리하는 작업
- 자바에서 추상화를 위해 제공하는 가장 유용한 도구 => "인터페이스"
- ConnectionMaker 인터페이스의 도입
- 하지만! PostgreSqlConnectionManager 클래스의 생성자를 호출해서 객체를 생성하는 코드가 아직 UserDao에 남아있다!

### 3.3 관계설정 책임의 분리
- UserDao를 사용하는 클라이언트가 존재할 것이다
- 두 개의 객체가 있고 한 객체가 다른 객체의 기능을 사용한다면, 사용되는 쪽이 사용하는 쪽에게 서비스를 제공하는 셈이다
- 따라서 사용되는 객체를 서비스, 사용하는 객체를 클라이언트라고 부를 수 있다
- UserDao의 클라이언트 => UserDao를 사용하는 객체로 말할 수 있다
- 왜 이런 얘기를 하는가!?

#### 3.3.a 제3의 관심사항인 UserDao와 ConnectionMaker의 구현 클래스의 관계를 결정해주는 기능을 분리해서 두기에 적절한 곳이다!
- 객체 사이의 관계 => 일단 만들어진 객체가 있어야 한다, 이처럼 직접 생성자를 호출하거나, 외부에서 만들어 준것을 가져오는 방법이 있다
- 이 객체를 꼭 UserDao 내부에서 만들 필요는 없다!
- 객체는 얼마든지 메소드 파라미터나 생성자 파라미터를 통해 전달할 수 있다

#### 3.3.b 이 때 파라미터의 타입을 전달받은 객체의 인터페이스로 선언해 두었다고 가정해보자
- 이런 경우 파라미터로 전달되는 객체의 클래스는 해당 인터페이스를 구현하기만 했다면 어떤 것이든지 상관 없다
- 결과적으로 UserDao 객체가 동작하려면 특정 클래스의 객체와 관계를 맺어야 한다
- 하지만 클래스 사이에 관계가 만들어진 것은 아니고, 객체 사이에 다이내믹한 관계가 만들어지는 것이다
- 코드에서는 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면, 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있다
- 이 것이 바로 객체 지향 프로그램의 다형성이라는 특징이다!
  
#### 3.3.c UserDao 객체가 PostgreSqlConnectionManager 객체를 사용하게 하려면 두 객체 사이에 런타임 사용관계 또는 의존관계라고 불리는 관계를 맺어주면 된다
- 제3의 객체인 UserDao의 클라이언트는 무슨 역할을 하는 것일까?
1. 클라이언트는 자기가 UserDao를 사용해야 할 입장이기 때문에 UserDao의 세부 전략인 ConnectionMaker의 구현 클래스를 선택한다
2. 선택한 클래스의 객체를 생성해서 UserDao와 연결한다
- 기존의 UserDao에서는 생성자에게 이 책임이 있었다
- 자신이 사용할 객체를 직접만들어서, 자신과 관계를 만들어버리는 것이 기존의 역할이다.
- 다시 말하지만!! 이것은 UserDao의 관심도 아니고 책임도 아니다
- 다른 관심사가 함께 있으니 확장성이 떨어지는 것이다

#### 3.3.d UserDao를 사용하는 main() 메소드를 UserDaoTest 라는 새로운 클래스로 분리!
- UserDao => 자신의 관심사이자 책임인 사용자 데이터 엑세스 작업을 위해 SQL을 생성하고, 실행하는 데만 집중할 수 있게 됨
- 더 이상 DB 생성 방법이나 어떤 DB를 사용할지에 대한 전략은 조금도 고민할 필요가 없음
- UserDaoTest가 connectionMaker 클래스를 선정하는 책임을 맡음

### 3.4 원칙과 패턴
- 개방 폐쇄 원칙 (OCP, Open-Closed Principle) : 깔끔한 설계를 위한 객체 지향 설계 원칙 중의 하나
1. 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다
2. 예) UserDao는 DB 연결 방법이라는 기능을 확장하는 데는 열려있음 (어떤 DB를 사용해도 무관, ConnectionMaker로 Connection을 느슨하게 연결하고 있음)
동시에 UserDao는 자신의 핵심 기능을 구현한 데이터 엑세스 로직은 그런 변화에 영향을 받지 않고 유지할수 있으므로 변경에는 닫혀있음
   
- SOLID (객체 지향 설계 원칙)
1. SRP(The Single Responsibility Principle) : 단일 책임 원칙
2. OCP(The Open Closed Principle) : 개방 폐쇄 원칙
3. LSP(The Liskov Substituion Principle) : 리스코프 치환 원칙
4. ISP(The Interface Segregation Principle) : 인터페이스 분리 원칙
5. DIP(The Dependency Inversion Principle): 의존관계 역전 원칙
   



