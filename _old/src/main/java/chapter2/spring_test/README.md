## 4. 스프링 테스트 적용 (spring_test package)

- 테스트는 가능한 한 독립적으로 매번 새로운 오브젝트를 만들어서 사용하는 것이 원칙이다
- 하지만 애플리케이션 컨텍스트처럼 생성에 많은 시간과 자원이 소모되는 경우에는 테스트 전체가 공유하는 오브젝트를 만들기도 한다 => JUnit5에서는 @BeforeAll로 충분해 보임
- 이때도 테스트는 일관성 있는 실행 결과를 보장해야 하고, 테스트의 실행 순서가 결과에 영향을 미치지 않아야 한다
- 다행히도 애플리케이션 컨텍스트는 초기화되고 나면 내부의 상태가 바뀌는 일은 거의 없다
- 빈은 싱글톤으로 만들었기 때문에 상태를 갖지 않는다
- JUnit5의 @BeforeAll 보다 스프링이 직접 제공하는 애플리케이션 컨텍스트 테스트 지원 기능을 사용해보자

### 1. 테스트를 위한 애플리케이션 컨텍스트 관리

- @ExtendWith(SpringExtension.class) : JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 애노테이션  
  JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다
- @ContextConfiguration(classes = {DaoFactory.class}) : 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정

#### 테스트 메소드의 컨텍스트 공유

- JUnit 확장 기능은 테스트가 실행되기 전에 딱 한 번만 애플리케이션 컨텍스트를 만들어둔다
- 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트를 자신의 테스트 오브젝트의 특정 필드에 주입해주는 것이다
- 일종의 DI로 불 수 있다

#### 테스트 클래스의 컨텍스트 공유

- 하나의 테스트 클래스 안에서 애플리케이션 컨텍스트를 공유해주는 것이 전부가 아니다!
- 여러 개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다


- @Autowired : 스프링의 DI에서 사용되는 특별한 애노테이션
- @Autowired가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다
- 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다
- 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록한다
- 따라서 애플리케이션 컨텍스트에는 ApplicationContext 타입의 빈이 존재하는 셈이고 DI도 가능한 것이다

### 2. DI와 테스트

- DI를 사용해야 하는 이유
    1. 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없다
    2. 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하면 다른 차원의 서비스 기능을 도입할 수 있다 (1장의 CountingConnectionMaker)
    3. 테스트 => 효율적인 테스트를 손쉽게 만들기 위함  
       테스트를 잘 활용하려면 자동으로 실행 가능하며 빠르게 동작하는 테스트 코드를 만들어야 함  
       그러기 위해서는 가능한 한 작은 단위의 대상에 국한해서 테스트해야 한다  
       DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는 데 중요한 역할을 한다

#### 테스트 코드에 의한 DI

- 애플리케이션이 사용할 DataSource 빈은 서버의 DB 풀 서비스와 연결해서 운영용 DB 커넥션을 돌려주도록 만들어져 있다고 해보자
- 테스트를 할 때 이 DataSource를 이용해도 될까?
- UserDaoTest를 실행하는 순난 deleteAll()에 의해 운영용 DB의 사용자 정보가 모두 삭제된다면?
- 결코 일어나서는 안 되는 일이다
- 이런 경우엔 테스트 코드에 의한 DI를 이용해서 테스트 중에 DAO가 사용할 DataSource 오브젝트르 바꿔주는 방법을 이용하면 된다


- @DirtiesContext : 테스트 메소드에서 애플리케이션 컨텍스트의 구성이나 상태를 변경한다는 것을 테스트 컨텍스트 프레임워크에 알려준다
- 테스트 컨텍스트는 이 애노테이션이 붙은 테스트 클래스에는 애플리케이션 컨텍스트 공유를 허용하지 않는다
- 테스트 메소드를 수행하고 나면 매번 새로운 애플리케이션 컨텍스트르 만들어서 다음 테스트가 사용하게 해준다
- 테스트 중에 변경한 컨텍스트가 뒤의 테스트에 영향을 주지 않게 하기 위해서다
- 하지만 이 떄문에 애플리케이션 컨텍스트를 매번 만드는건 조금 찜찜하다

#### 테스트를 위한 별도의 DI 설정

- 자바 설정파일인 DaoFactory를 분리한다
- 테스트 클래스는 TestDaoFactory 설정 정보를 이용하게 한다

#### 컨테이너 없는 DI 테스트

- 스프링 컨테이너 없이 테스트 코드의 수동 DI만을 이용해 테스트를 작성할 수 있다
- UserDao가 스프링 API에 의존하지 않고 자신의 관심에만 집중해서 깔끔하게 만들어진 코드이기 떄문에 가능한 일이다
- 바로 이런 가볍고 깔끔한 테스트를 만들 수 있는 이유도 DI를 적용했기 떄문이다
- DI는 객체지향 프로그래밍 스타일이다
- 따라서 DI를 위해 컨테이너가 반드시 필요한 것은 아니다
- DI 컨테이너나 프레임워크는 DI를 편하게 적용하도록 도움을 줄 뿐, 컨테이너가 DI를 가능하게 해주는 것은 아니다
- 스프링 => 비침투적인 기술   
  => 애플리케이션 로직을 담은 코드에 아무런 영향을 주지 않고 적용이 가능   
  => 기술에 종속적이지 않은 순수한 코드를 유지할 수 있게 함

#### DI를 이용한 테스트 방법 선택
1. 항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 우선적으로 고려하자  
   => 테스트 수행 속도가 가장 빠르고 테스트 자체가 간결하다
2. 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트 할 경우  
   => 스프링의 설정을 이용한 DI 방식의 테스트를 이용하면 편리하다
   => 테스트에서 애플리케이션 컨텍스트를 사용하느 겨웅에는 테스트 전용 설정파일을 따로 만들어 사용하는 편이 좋다
3. 테스트 설정을 따로 만들었다고 하더라도 때로는 예외적인 의존관계를 강제로 구성해서 테스트해야 할 경우가 있다
   => 테스트 코드로 수동 DI 해서 테스트하는 방법을 사용하자
   => 테스트 메소드나 클래스에 @DirtiesContext 애노테이션을 붙이자
  